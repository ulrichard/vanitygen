Description: building with cmake
 .
 vanitygen (0.21-1) unstable; urgency=low
 .
   * Initial packaging for Debian (Closes: #718860)
Author: Richard Ulrich <richi@paraeasy.ch>
Bug-Debian: http://bugs.debian.org/718860

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- /dev/null
+++ vanitygen-0.21/FindPCRE.cmake
@@ -0,0 +1,53 @@
+# Martin Konrad <kon...@ikp.tu-darmstadt.de>
+# License: GPLv2/v3
+#
+# Try to find libpcre (Perl Compatible Regular Expressions)
+#
+# Once done this will define
+#
+# PCRE_FOUND - system has libpcre
+# PCRE_INCLUDE_DIR - the libpcre include directory
+# PCRE_LIBRARY - where to find libpcre
+# PCRE_LIBRARIES - Link these to use libpcre
+
+if(PCRE_INCLUDE_DIR AND PCRE_LIBRARIES)
+        # in cache already
+        set(LIBUSB_FOUND TRUE)
+else(PCRE_INCLUDE_DIR AND PCRE_LIBRARIES)
+        if(NOT WIN32)
+                # use pkg-config to get the directories and then use these values
+                # in the FIND_PATH() and FIND_LIBRARY() calls
+                find_package(PkgConfig)
+                pkg_check_modules(PC_PCRE libpcre)
+        endif(NOT WIN32)
+
+        find_path(PCRE_INCLUDE_DIR
+                NAMES
+                        pcre.h
+                HINTS
+                        ${PCRE_PKG_INCLUDE_DIRS}
+                PATHS
+                        /usr/include
+                        /usr/local/include
+        )
+
+        find_library(PCRE_LIBRARY
+                NAMES
+                        pcre
+                HINTS
+                        ${PCRE_PKG_LIBRARY_DIRS}
+                PATHS
+                        /usr/lib
+                        /usr/local/lib
+        )
+
+        set(PCRE_LIBRARIES ${PCRE_LIBRARY})
+
+        # handle the QUIETLY AND REQUIRED arguments AND set PCRE_FOUND to TRUE if
+        # all listed variables are TRUE
+        # include(${CMAKE_CURRENT_LIST_DIR}/FindPackageHandleStandardArgs.cmake)
+        include(FindPackageHandleStandardArgs)
+        find_package_handle_standard_args(PCRE DEFAULT_MSG PCRE_LIBRARY PCRE_INCLUDE_DIR)
+
+        mark_as_advanced(PCRE_INCLUDE_DIR PCRE_LIBRARY)
+endif(PCRE_INCLUDE_DIR AND PCRE_LIBRARIES)
--- /dev/null
+++ vanitygen-0.21/CMakeLists.txt
@@ -0,0 +1,75 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
+
+PROJECT(vanitygen)
+SET(CMAKE_MODULE_PATH ${vanitygen_SOURCE_DIR})
+SET(CMAKE_THREAD_PREFER_PTHREAD True)
+
+FIND_PACKAGE(OpenSSL REQUIRED)
+FIND_PACKAGE(Threads REQUIRED)
+FIND_PACKAGE(PCRE    REQUIRED)
+FIND_PACKAGE(CURL)
+FIND_PACKAGE(OpenCL)
+
+INCLUDE_DIRECTORIES(${OPENSSL_INCLUDE_DIR})
+INCLUDE_DIRECTORIES(${PCRE_INCLUDE_DIR})
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR})
+
+SET(VANY_LIBS
+	${PCRE_LIBRARIES}
+	${OPENSSL_LIBRARIES}
+	m
+	${CMAKE_THREAD_LIBS_INIT}
+)
+
+ADD_EXECUTABLE(vanitygen
+	vanitygen.c
+	pattern.c
+	util.c
+)
+TARGET_LINK_LIBRARIES(vanitygen
+	${VANY_LIBS}
+)
+
+ADD_EXECUTABLE(keyconv
+	keyconv.c
+	util.c
+)
+TARGET_LINK_LIBRARIES(keyconv
+	${VANY_LIBS}
+)
+
+IF(OPENCL_FOUND)
+	INCLUDE_DIRECTORIES(${OPENCL_INCLUDE_DIRS})
+
+	ADD_EXECUTABLE(oclvanitygen
+		oclvanitygen.c
+		oclengine.c
+		pattern.c
+		util.c
+	)
+	TARGET_LINK_LIBRARIES(oclvanitygen
+		${VANY_LIBS}
+	    ${OPENCL_LIBRARIES}
+	)
+
+	IF(CURL_FOUND)
+		INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIRS})
+		ADD_EXECUTABLE(oclvanityminer
+			oclvanityminer.c
+			oclengine.c
+			pattern.c
+			util.c
+		)
+		TARGET_LINK_LIBRARIES(oclvanityminer
+			${VANY_LIBS}
+			${OPENCL_LIBRARIES}
+			${CURL_LIBRARIES}
+		)
+	ENDIF(CURL_FOUND)
+ENDIF(OPENCL_FOUND)
+
+
+
+
+
+
--- /dev/null
+++ vanitygen-0.21/FindOpenCL.cmake
@@ -0,0 +1,103 @@
+#
+#  This file taken from FindOpenCL project @ http://gitorious.com/findopencl
+#
+# - Try to find OpenCL
+# This module tries to find an OpenCL implementation on your system. It supports
+# AMD / ATI, Apple and NVIDIA implementations, but shoudl work, too.
+#
+# Once done this will define
+#  OPENCL_FOUND        - system has OpenCL
+#  OPENCL_INCLUDE_DIRS  - the OpenCL include directory
+#  OPENCL_LIBRARIES    - link these to use OpenCL
+#
+# WIN32 should work, but is untested
+
+FIND_PACKAGE( PackageHandleStandardArgs )
+
+SET (OPENCL_VERSION_STRING "0.1.0")
+SET (OPENCL_VERSION_MAJOR 0)
+SET (OPENCL_VERSION_MINOR 1)
+SET (OPENCL_VERSION_PATCH 0)
+
+IF (APPLE)
+
+  FIND_LIBRARY(OPENCL_LIBRARIES OpenCL DOC "OpenCL lib for OSX")
+  FIND_PATH(OPENCL_INCLUDE_DIRS OpenCL/cl.h DOC "Include for OpenCL on OSX")
+  FIND_PATH(_OPENCL_CPP_INCLUDE_DIRS OpenCL/cl.hpp DOC "Include for OpenCL CPP bindings on OSX")
+
+ELSE (APPLE)
+
+	IF (WIN32)
+	
+	    FIND_PATH(OPENCL_INCLUDE_DIRS CL/cl.h)
+	    FIND_PATH(_OPENCL_CPP_INCLUDE_DIRS CL/cl.hpp)
+	
+	    # The AMD SDK currently installs both x86 and x86_64 libraries
+	    # This is only a hack to find out architecture
+	    IF( ${CMAKE_SYSTEM_PROCESSOR} STREQUAL "AMD64" )
+	    	SET(OPENCL_LIB_DIR "$ENV{ATISTREAMSDKROOT}/lib/x86_64")
+			SET(OPENCL_LIB_DIR "$ENV{ATIINTERNALSTREAMSDKROOT}/lib/x86_64")
+	    ELSE (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "AMD64")
+	    	SET(OPENCL_LIB_DIR "$ENV{ATISTREAMSDKROOT}/lib/x86")
+	   		SET(OPENCL_LIB_DIR "$ENV{ATIINTERNALSTREAMSDKROOT}/lib/x86")
+	    ENDIF( ${CMAKE_SYSTEM_PROCESSOR} STREQUAL "AMD64" )
+
+	    # find out if the user asked for a 64-bit build, and use the corresponding 
+	    # 64 or 32 bit NVIDIA library paths to the search:
+	    STRING(REGEX MATCH "Win64" ISWIN64 ${CMAKE_GENERATOR})
+	    IF("${ISWIN64}" STREQUAL "Win64") 
+	    	FIND_LIBRARY(OPENCL_LIBRARIES OpenCL.lib ${OPENCL_LIB_DIR} $ENV{CUDA_LIB_PATH} $ENV{CUDA_PATH}/lib/x64)
+	    ELSE("${ISWIN64}" STREQUAL "Win64") 
+	    	FIND_LIBRARY(OPENCL_LIBRARIES OpenCL.lib ${OPENCL_LIB_DIR} $ENV{CUDA_LIB_PATH} $ENV{CUDA_PATH}/lib/Win32)
+	    ENDIF("${ISWIN64}" STREQUAL "Win64") 
+
+	    GET_FILENAME_COMPONENT(_OPENCL_INC_CAND ${OPENCL_LIB_DIR}/../../include ABSOLUTE)
+	    
+	    # On Win32 search relative to the library
+	    FIND_PATH(OPENCL_INCLUDE_DIRS CL/cl.h PATHS "${_OPENCL_INC_CAND}" $ENV{CUDA_INC_PATH} $ENV{CUDA_PATH}/include)
+	    FIND_PATH(_OPENCL_CPP_INCLUDE_DIRS CL/cl.hpp PATHS "${_OPENCL_INC_CAND}" $ENV{CUDA_INC_PATH} $ENV{CUDA_PATH}/include)
+	
+	ELSE (WIN32)
+
+            # Unix style platforms
+            FIND_LIBRARY(OPENCL_LIBRARIES OpenCL
+              ENV LD_LIBRARY_PATH
+			  "/usr/lib/nvidia-current"
+			  "/usr/lib/beignet"
+			  "/usr/lib/x86_64-linux-gnu"
+			  "/usr/lib/x86-linux-gnu"
+            )
+
+            GET_FILENAME_COMPONENT(OPENCL_LIB_DIR ${OPENCL_LIBRARIES} PATH)
+            GET_FILENAME_COMPONENT(_OPENCL_INC_CAND ${OPENCL_LIB_DIR}/../../include ABSOLUTE)
+
+            # The AMD SDK currently does not place its headers
+            # in /usr/include, therefore also search relative
+            # to the library
+            FIND_PATH(OPENCL_INCLUDE_DIRS CL/cl.h PATHS 
+		${_OPENCL_INC_CAND} 
+		"/usr/local/cuda/include" 
+		"/usr/include/nvidia-current"
+		)
+            FIND_PATH(_OPENCL_CPP_INCLUDE_DIRS CL/cl.hpp PATHS 
+		${_OPENCL_INC_CAND} 
+		"/usr/local/cuda/include" 
+		"/usr/include/nvidia-current"
+		)
+
+	ENDIF (WIN32)
+
+ENDIF (APPLE)
+
+FIND_PACKAGE_HANDLE_STANDARD_ARGS( OpenCL DEFAULT_MSG OPENCL_LIBRARIES OPENCL_INCLUDE_DIRS )
+
+IF( _OPENCL_CPP_INCLUDE_DIRS )
+	SET( OPENCL_HAS_CPP_BINDINGS TRUE )
+	LIST( APPEND OPENCL_INCLUDE_DIRS ${_OPENCL_CPP_INCLUDE_DIRS} )
+	# This is often the same, so clean up
+	LIST( REMOVE_DUPLICATES OPENCL_INCLUDE_DIRS )
+ENDIF( _OPENCL_CPP_INCLUDE_DIRS )
+
+MARK_AS_ADVANCED(
+  OPENCL_INCLUDE_DIRS
+)
